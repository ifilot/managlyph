diff --git a/src/data/container.h b/src/data/container.h
index 2696eea3dc8dacebba8a50dd7cd4e501d28da99f..9a258e8e0165a411a5409e97ff612fcdfa64672d 100644
--- a/src/data/container.h
+++ b/src/data/container.h
@@ -10,53 +10,62 @@
  *   any later version.                                                   *
  *                                                                        *
  *   MANAGLYPH is distributed in the hope that it will be useful,         *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty          *
  *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.              *
  *   See the GNU General Public License for more details.                 *
  *                                                                        *
  *   You should have received a copy of the GNU General Public License    *
  *   along with this program.  If not, see http://www.gnu.org/licenses/.  *
  *                                                                        *
  **************************************************************************/
 
 #ifndef CONTAINER_H
 #define CONTAINER_H
 
 #include <vector>
 #include <memory>
 #include <exception>
 
 #include "frame.h"
 
 class Container
 {
 private:
     std::vector<std::shared_ptr<Frame>> frames;
+    bool flag_is_neb_pathway = false;
 
 public:
     Container();
 
     inline void add_frame(const std::shared_ptr<Frame> frame) {
         this->frames.push_back(frame);
     }
 
     inline std::shared_ptr<Frame> frame(unsigned int frame_id) {
         if(frame_id >= frames.size()) {
             throw std::runtime_error("Invalid frame id: " + std::to_string(frame_id)
                                      + "/" + std::to_string(frames.size()));
         }
         return this->frames[frame_id];
     }
 
     inline size_t get_nr_frames() const {
         return this->frames.size();
     }
 
+    inline void set_is_neb_pathway(bool is_neb_pathway) {
+        this->flag_is_neb_pathway = is_neb_pathway;
+    }
+
+    inline bool is_neb_pathway() const {
+        return this->flag_is_neb_pathway;
+    }
+
     /**
      * @brief Get maximum dimension of all objects
      * @return Maximal dimension
      */
     float get_max_dim() const;
 };
 
 #endif // CONTAINER_H
diff --git a/src/data/container_loader.cpp b/src/data/container_loader.cpp
index ad83562911b09b821f584a928310f8b464bab870..ad71a2c41320458e638c719cb19bca1705ad8e99 100644
--- a/src/data/container_loader.cpp
+++ b/src/data/container_loader.cpp
@@ -14,64 +14,85 @@
  *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.              *
  *   See the GNU General Public License for more details.                 *
  *                                                                        *
  *   You should have received a copy of the GNU General Public License    *
  *   along with this program.  If not, see http://www.gnu.org/licenses/.  *
  *                                                                        *
  **************************************************************************/
 
 #include "container_loader.h"
 
 #include <array>
 #include <cmath>
 #include <limits>
 #include <sstream>
 #include <vector>
 #include <zstd.h>
 
 /**
  * @brief ContainerLoader constructor
  */
 ContainerLoader::ContainerLoader() {}
 
 namespace {
 
 constexpr unsigned int NEB_INTERPOLATION_STEPS_PER_SEGMENT = 10;
+constexpr float UNIT_CELL_EPSILON = 1e-3f;
 
 glm::vec3 catmull_rom(const glm::vec3& p0,
                       const glm::vec3& p1,
                       const glm::vec3& p2,
                       const glm::vec3& p3,
                       float t) {
     const float t2 = t * t;
     const float t3 = t2 * t;
     return 0.5f * ((2.0f * p1) +
                    (-p0 + p2) * t +
                    (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +
                    (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);
 }
 
+glm::vec3 wrap_delta_unit_cell(const glm::vec3& delta) {
+    return glm::vec3(delta.x - std::round(delta.x),
+                     delta.y - std::round(delta.y),
+                     delta.z - std::round(delta.z));
+}
+
+bool is_fractional_unit_cell_coordinates(const std::vector<std::shared_ptr<Frame>>& frames) {
+    for (const auto& frame : frames) {
+        for (const auto& atom : frame->get_structure()->get_atoms()) {
+            if (atom.x < -UNIT_CELL_EPSILON || atom.x > 1.0f + UNIT_CELL_EPSILON ||
+                atom.y < -UNIT_CELL_EPSILON || atom.y > 1.0f + UNIT_CELL_EPSILON ||
+                atom.z < -UNIT_CELL_EPSILON || atom.z > 1.0f + UNIT_CELL_EPSILON) {
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
 } // namespace
 
 /**
  * @brief      Loads an abo file from hard drive stored as little endian binary
  *
  * @param[in]  path   Path to file
  */
 std::shared_ptr<Container> ContainerLoader::load_data_abo(const std::string& path) {
     qDebug() << "Start reading abo file:" << path.c_str();
 
     auto container = std::make_shared<Container>();
     std::ifstream file(path, std::ios::binary);
 
     if (!file)
         throw std::runtime_error("Could not open file: " + path);
 
     auto read_or_throw = [&](std::istream& stream, char* data, std::size_t size) {
         if (size == 0) return;
         stream.read(data, size);
         if (!stream)
             throw std::runtime_error("Corrupt ABO file (unexpected EOF): " + path);
     };
 
     enum class NormalEncoding {
         Float32,
@@ -254,94 +275,105 @@ std::shared_ptr<Container> ContainerLoader::load_data_abo(const std::string& pat
                     normals[k] = decode_octahedral_normal(nx, ny);
                 }
             }
 
             uint32_t nr_faces = 0;
             read_or_throw(input, reinterpret_cast<char*>(&nr_faces), sizeof(nr_faces));
 
             std::vector<uint32_t> indices(nr_faces * 3);
             if (!indices.empty())
                 read_or_throw(input, reinterpret_cast<char*>(indices.data()), indices.size() * sizeof(uint32_t));
 
             qDebug() << "Model idx:" << model_idx << "faces:" << nr_faces;
 
             if(nr_vertices == 0 || nr_faces == 0) {
                 qDebug() << "Skipping empty model:" << model_idx;
             } else {
                 auto model = std::make_shared<Model>(v_positions, normals, indices);
                 model->set_color(color);
                 frame->add_model(model);
             }
         }
 
         loaded_frames.push_back(frame);
     }
 
+    container->set_is_neb_pathway(is_neb_pathway);
+
     if (is_neb_pathway && loaded_frames.size() >= 2) {
         const auto& reference_atoms = loaded_frames.front()->get_structure()->get_atoms();
         const size_t nr_atoms = reference_atoms.size();
+        const bool use_unit_cell_minimal_image = is_fractional_unit_cell_coordinates(loaded_frames);
+
+        if (!use_unit_cell_minimal_image) {
+            qWarning() << "NEB interpolation uses raw coordinates because unit-cell fractional coordinates were not detected.";
+        }
 
         bool can_interpolate = nr_atoms > 0;
         for (size_t frame_idx = 1; frame_idx < loaded_frames.size() && can_interpolate; ++frame_idx) {
             const auto& atoms = loaded_frames[frame_idx]->get_structure()->get_atoms();
             if (atoms.size() != nr_atoms) {
                 can_interpolate = false;
                 break;
             }
             for (size_t atom_idx = 0; atom_idx < nr_atoms; ++atom_idx) {
                 if (atoms[atom_idx].atnr != reference_atoms[atom_idx].atnr) {
                     can_interpolate = false;
                     break;
                 }
             }
         }
 
         if (!can_interpolate) {
             qWarning() << "NEB interpolation skipped due to incompatible atom ordering between frames.";
         } else {
             std::vector<std::shared_ptr<Frame>> interpolated_frames;
             interpolated_frames.reserve((loaded_frames.size() - 1) * NEB_INTERPOLATION_STEPS_PER_SEGMENT + 1);
 
             const auto make_interpolated_frame = [&](size_t seg_idx, float t) {
                 const size_t i0 = (seg_idx == 0) ? seg_idx : seg_idx - 1;
                 const size_t i1 = seg_idx;
                 const size_t i2 = seg_idx + 1;
                 const size_t i3 = (seg_idx + 2 < loaded_frames.size()) ? seg_idx + 2 : loaded_frames.size() - 1;
 
                 const auto& atoms0 = loaded_frames[i0]->get_structure()->get_atoms();
                 const auto& atoms1 = loaded_frames[i1]->get_structure()->get_atoms();
                 const auto& atoms2 = loaded_frames[i2]->get_structure()->get_atoms();
                 const auto& atoms3 = loaded_frames[i3]->get_structure()->get_atoms();
 
                 auto structure = std::make_shared<Structure>();
                 for (size_t atom_idx = 0; atom_idx < nr_atoms; ++atom_idx) {
                     const glm::vec3 p0(atoms0[atom_idx].x, atoms0[atom_idx].y, atoms0[atom_idx].z);
                     const glm::vec3 p1(atoms1[atom_idx].x, atoms1[atom_idx].y, atoms1[atom_idx].z);
                     const glm::vec3 p2(atoms2[atom_idx].x, atoms2[atom_idx].y, atoms2[atom_idx].z);
                     const glm::vec3 p3(atoms3[atom_idx].x, atoms3[atom_idx].y, atoms3[atom_idx].z);
 
-                    const glm::vec3 ipos = catmull_rom(p0, p1, p2, p3, t);
+                    const glm::vec3 p0_mic = use_unit_cell_minimal_image ? p1 + wrap_delta_unit_cell(p0 - p1) : p0;
+                    const glm::vec3 p2_mic = use_unit_cell_minimal_image ? p1 + wrap_delta_unit_cell(p2 - p1) : p2;
+                    const glm::vec3 p3_mic = use_unit_cell_minimal_image ? p2_mic + wrap_delta_unit_cell(p3 - p2) : p3;
+
+                    const glm::vec3 ipos = catmull_rom(p0_mic, p1, p2_mic, p3_mic, t);
                     structure->add_atom(atoms1[atom_idx].atnr, ipos.x, ipos.y, ipos.z);
                 }
                 structure->update();
 
                 std::ostringstream descriptor;
                 descriptor.precision(std::numeric_limits<float>::max_digits10);
                 descriptor << "NEB interpolated frame " << seg_idx << " t=" << t;
                 return std::make_shared<Frame>(structure, descriptor.str());
             };
 
             for (size_t seg_idx = 0; seg_idx + 1 < loaded_frames.size(); ++seg_idx) {
                 for (unsigned int step = 0; step < NEB_INTERPOLATION_STEPS_PER_SEGMENT; ++step) {
                     const float t = static_cast<float>(step) /
                                     static_cast<float>(NEB_INTERPOLATION_STEPS_PER_SEGMENT);
                     interpolated_frames.push_back(make_interpolated_frame(seg_idx, t));
                 }
             }
 
             interpolated_frames.push_back(loaded_frames.back());
             loaded_frames = std::move(interpolated_frames);
             qDebug() << "Generated interpolated NEB frames:" << loaded_frames.size();
         }
     }
 
     for (const auto& frame : loaded_frames) {
diff --git a/src/gui/interface_window.cpp b/src/gui/interface_window.cpp
index 128bb4e12cb0715fc9deab043525e641fb59d58b..0aa27d8b3a59554c0c50d7733b0f0b76f12e7cc9 100644
--- a/src/gui/interface_window.cpp
+++ b/src/gui/interface_window.cpp
@@ -245,51 +245,59 @@ void InterfaceWindow::build_sequence_interface() {
  * @brief      Button press event
  *
  * @param      event  The event
  */
 void InterfaceWindow::keyPressEvent(QKeyEvent *e) {
     QWidget::keyPressEvent(e);
 }
 
 /**
  * @brief      Opens a file.
  *
  * @param[in]  filename  The filename
  *
  * @return     loading time of object in seconds
  */
 void InterfaceWindow::open_file(const QString& filename) {
     qDebug() << "Opening file: " << filename;
 
     try {
         this->container = this->conload.load_data_abo(filename.toStdString());
     } catch(const std::exception& e) {
         QMessageBox::critical(this, tr("Exception encountered"), tr(e.what()) );
         return;
     }
 
-    this->playback_fps = 1;
+    if (this->container && this->container->is_neb_pathway()) {
+        this->set_axes_enabled(false);
+        this->set_pingpong_enabled(true);
+        this->set_rotation_enabled(false);
+        this->playback_fps = 60;
+    } else {
+        this->playback_fps = 1;
+    }
+
     if (this->fps_dropdown) {
         const int fps_index = this->fps_dropdown->findData(this->playback_fps);
         if (fps_index >= 0) {
             this->fps_dropdown->setCurrentIndex(fps_index);
         }
     }
 
     this->frame_direction = 1;
     emit new_container_loaded();
 }
 
 /**
  * @brief      Sets the camera align.
  *
  * @param      action  The action
  */
 void InterfaceWindow::set_camera_align(QAction* action) {
     this->anaglyph_widget->set_camera_alignment(action->data().toInt());
 }
 
 /**
  * @brief      Sets the camera mode (orthogonal or perspective).
  *
  * @param      action  The action
  */
diff --git a/src/data/container.h b/src/data/container.h
index 2696eea3dc8dacebba8a50dd7cd4e501d28da99f..9a258e8e0165a411a5409e97ff612fcdfa64672d 100644
--- a/src/data/container.h
+++ b/src/data/container.h
@@ -10,53 +10,62 @@
  *   any later version.                                                   *
  *                                                                        *
  *   MANAGLYPH is distributed in the hope that it will be useful,         *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty          *
  *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.              *
  *   See the GNU General Public License for more details.                 *
  *                                                                        *
  *   You should have received a copy of the GNU General Public License    *
  *   along with this program.  If not, see http://www.gnu.org/licenses/.  *
  *                                                                        *
  **************************************************************************/
 
 #ifndef CONTAINER_H
 #define CONTAINER_H
 
 #include <vector>
 #include <memory>
 #include <exception>
 
 #include "frame.h"
 
 class Container
 {
 private:
     std::vector<std::shared_ptr<Frame>> frames;
+    bool flag_is_neb_pathway = false;
 
 public:
     Container();
 
     inline void add_frame(const std::shared_ptr<Frame> frame) {
         this->frames.push_back(frame);
     }
 
     inline std::shared_ptr<Frame> frame(unsigned int frame_id) {
         if(frame_id >= frames.size()) {
             throw std::runtime_error("Invalid frame id: " + std::to_string(frame_id)
                                      + "/" + std::to_string(frames.size()));
         }
         return this->frames[frame_id];
     }
 
     inline size_t get_nr_frames() const {
         return this->frames.size();
     }
 
+    inline void set_is_neb_pathway(bool is_neb_pathway) {
+        this->flag_is_neb_pathway = is_neb_pathway;
+    }
+
+    inline bool is_neb_pathway() const {
+        return this->flag_is_neb_pathway;
+    }
+
     /**
      * @brief Get maximum dimension of all objects
      * @return Maximal dimension
      */
     float get_max_dim() const;
 };
 
 #endif // CONTAINER_H
diff --git a/src/data/container_loader.cpp b/src/data/container_loader.cpp
index ad83562911b09b821f584a928310f8b464bab870..ad71a2c41320458e638c719cb19bca1705ad8e99 100644
--- a/src/data/container_loader.cpp
+++ b/src/data/container_loader.cpp
@@ -14,64 +14,85 @@
  *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.              *
  *   See the GNU General Public License for more details.                 *
  *                                                                        *
  *   You should have received a copy of the GNU General Public License    *
  *   along with this program.  If not, see http://www.gnu.org/licenses/.  *
  *                                                                        *
  **************************************************************************/
 
 #include "container_loader.h"
 
 #include <array>
 #include <cmath>
 #include <limits>
 #include <sstream>
 #include <vector>
 #include <zstd.h>
 
 /**
  * @brief ContainerLoader constructor
  */
 ContainerLoader::ContainerLoader() {}
 
 namespace {
 
 constexpr unsigned int NEB_INTERPOLATION_STEPS_PER_SEGMENT = 10;
+constexpr float UNIT_CELL_EPSILON = 1e-3f;
 
 glm::vec3 catmull_rom(const glm::vec3& p0,
                       const glm::vec3& p1,
                       const glm::vec3& p2,
                       const glm::vec3& p3,
                       float t) {
     const float t2 = t * t;
     const float t3 = t2 * t;
     return 0.5f * ((2.0f * p1) +
                    (-p0 + p2) * t +
                    (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +
                    (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3);
 }
 
+glm::vec3 wrap_delta_unit_cell(const glm::vec3& delta) {
+    return glm::vec3(delta.x - std::round(delta.x),
+                     delta.y - std::round(delta.y),
+                     delta.z - std::round(delta.z));
+}
+
+bool is_fractional_unit_cell_coordinates(const std::vector<std::shared_ptr<Frame>>& frames) {
+    for (const auto& frame : frames) {
+        for (const auto& atom : frame->get_structure()->get_atoms()) {
+            if (atom.x < -UNIT_CELL_EPSILON || atom.x > 1.0f + UNIT_CELL_EPSILON ||
+                atom.y < -UNIT_CELL_EPSILON || atom.y > 1.0f + UNIT_CELL_EPSILON ||
+                atom.z < -UNIT_CELL_EPSILON || atom.z > 1.0f + UNIT_CELL_EPSILON) {
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
 } // namespace
 
 /**
  * @brief      Loads an abo file from hard drive stored as little endian binary
  *
  * @param[in]  path   Path to file
  */
 std::shared_ptr<Container> ContainerLoader::load_data_abo(const std::string& path) {
     qDebug() << "Start reading abo file:" << path.c_str();
 
     auto container = std::make_shared<Container>();
     std::ifstream file(path, std::ios::binary);
 
     if (!file)
         throw std::runtime_error("Could not open file: " + path);
 
     auto read_or_throw = [&](std::istream& stream, char* data, std::size_t size) {
         if (size == 0) return;
         stream.read(data, size);
         if (!stream)
             throw std::runtime_error("Corrupt ABO file (unexpected EOF): " + path);
     };
 
     enum class NormalEncoding {
         Float32,
@@ -254,94 +275,105 @@ std::shared_ptr<Container> ContainerLoader::load_data_abo(const std::string& pat
                     normals[k] = decode_octahedral_normal(nx, ny);
                 }
             }
 
             uint32_t nr_faces = 0;
             read_or_throw(input, reinterpret_cast<char*>(&nr_faces), sizeof(nr_faces));
 
             std::vector<uint32_t> indices(nr_faces * 3);
             if (!indices.empty())
                 read_or_throw(input, reinterpret_cast<char*>(indices.data()), indices.size() * sizeof(uint32_t));
 
             qDebug() << "Model idx:" << model_idx << "faces:" << nr_faces;
 
             if(nr_vertices == 0 || nr_faces == 0) {
                 qDebug() << "Skipping empty model:" << model_idx;
             } else {
                 auto model = std::make_shared<Model>(v_positions, normals, indices);
                 model->set_color(color);
                 frame->add_model(model);
             }
         }
 
         loaded_frames.push_back(frame);
     }
 
+    container->set_is_neb_pathway(is_neb_pathway);
+
     if (is_neb_pathway && loaded_frames.size() >= 2) {
         const auto& reference_atoms = loaded_frames.front()->get_structure()->get_atoms();
         const size_t nr_atoms = reference_atoms.size();
+        const bool use_unit_cell_minimal_image = is_fractional_unit_cell_coordinates(loaded_frames);
+
+        if (!use_unit_cell_minimal_image) {
+            qWarning() << "NEB interpolation uses raw coordinates because unit-cell fractional coordinates were not detected.";
+        }
 
         bool can_interpolate = nr_atoms > 0;
         for (size_t frame_idx = 1; frame_idx < loaded_frames.size() && can_interpolate; ++frame_idx) {
             const auto& atoms = loaded_frames[frame_idx]->get_structure()->get_atoms();
             if (atoms.size() != nr_atoms) {
                 can_interpolate = false;
                 break;
             }
             for (size_t atom_idx = 0; atom_idx < nr_atoms; ++atom_idx) {
                 if (atoms[atom_idx].atnr != reference_atoms[atom_idx].atnr) {
                     can_interpolate = false;
                     break;
                 }
             }
         }
 
         if (!can_interpolate) {
             qWarning() << "NEB interpolation skipped due to incompatible atom ordering between frames.";
         } else {
             std::vector<std::shared_ptr<Frame>> interpolated_frames;
             interpolated_frames.reserve((loaded_frames.size() - 1) * NEB_INTERPOLATION_STEPS_PER_SEGMENT + 1);
 
             const auto make_interpolated_frame = [&](size_t seg_idx, float t) {
                 const size_t i0 = (seg_idx == 0) ? seg_idx : seg_idx - 1;
                 const size_t i1 = seg_idx;
                 const size_t i2 = seg_idx + 1;
                 const size_t i3 = (seg_idx + 2 < loaded_frames.size()) ? seg_idx + 2 : loaded_frames.size() - 1;
 
                 const auto& atoms0 = loaded_frames[i0]->get_structure()->get_atoms();
                 const auto& atoms1 = loaded_frames[i1]->get_structure()->get_atoms();
                 const auto& atoms2 = loaded_frames[i2]->get_structure()->get_atoms();
                 const auto& atoms3 = loaded_frames[i3]->get_structure()->get_atoms();
 
                 auto structure = std::make_shared<Structure>();
                 for (size_t atom_idx = 0; atom_idx < nr_atoms; ++atom_idx) {
                     const glm::vec3 p0(atoms0[atom_idx].x, atoms0[atom_idx].y, atoms0[atom_idx].z);
                     const glm::vec3 p1(atoms1[atom_idx].x, atoms1[atom_idx].y, atoms1[atom_idx].z);
                     const glm::vec3 p2(atoms2[atom_idx].x, atoms2[atom_idx].y, atoms2[atom_idx].z);
                     const glm::vec3 p3(atoms3[atom_idx].x, atoms3[atom_idx].y, atoms3[atom_idx].z);
 
-                    const glm::vec3 ipos = catmull_rom(p0, p1, p2, p3, t);
+                    const glm::vec3 p0_mic = use_unit_cell_minimal_image ? p1 + wrap_delta_unit_cell(p0 - p1) : p0;
+                    const glm::vec3 p2_mic = use_unit_cell_minimal_image ? p1 + wrap_delta_unit_cell(p2 - p1) : p2;
+                    const glm::vec3 p3_mic = use_unit_cell_minimal_image ? p2_mic + wrap_delta_unit_cell(p3 - p2) : p3;
+
+                    const glm::vec3 ipos = catmull_rom(p0_mic, p1, p2_mic, p3_mic, t);
                     structure->add_atom(atoms1[atom_idx].atnr, ipos.x, ipos.y, ipos.z);
                 }
                 structure->update();
 
                 std::ostringstream descriptor;
                 descriptor.precision(std::numeric_limits<float>::max_digits10);
                 descriptor << "NEB interpolated frame " << seg_idx << " t=" << t;
                 return std::make_shared<Frame>(structure, descriptor.str());
             };
 
             for (size_t seg_idx = 0; seg_idx + 1 < loaded_frames.size(); ++seg_idx) {
                 for (unsigned int step = 0; step < NEB_INTERPOLATION_STEPS_PER_SEGMENT; ++step) {
                     const float t = static_cast<float>(step) /
                                     static_cast<float>(NEB_INTERPOLATION_STEPS_PER_SEGMENT);
                     interpolated_frames.push_back(make_interpolated_frame(seg_idx, t));
                 }
             }
 
             interpolated_frames.push_back(loaded_frames.back());
             loaded_frames = std::move(interpolated_frames);
             qDebug() << "Generated interpolated NEB frames:" << loaded_frames.size();
         }
     }
 
     for (const auto& frame : loaded_frames) {
diff --git a/src/gui/interface_window.cpp b/src/gui/interface_window.cpp
index 128bb4e12cb0715fc9deab043525e641fb59d58b..0aa27d8b3a59554c0c50d7733b0f0b76f12e7cc9 100644
--- a/src/gui/interface_window.cpp
+++ b/src/gui/interface_window.cpp
@@ -245,51 +245,59 @@ void InterfaceWindow::build_sequence_interface() {
  * @brief      Button press event
  *
  * @param      event  The event
  */
 void InterfaceWindow::keyPressEvent(QKeyEvent *e) {
     QWidget::keyPressEvent(e);
 }
 
 /**
  * @brief      Opens a file.
  *
  * @param[in]  filename  The filename
  *
  * @return     loading time of object in seconds
  */
 void InterfaceWindow::open_file(const QString& filename) {
     qDebug() << "Opening file: " << filename;
 
     try {
         this->container = this->conload.load_data_abo(filename.toStdString());
     } catch(const std::exception& e) {
         QMessageBox::critical(this, tr("Exception encountered"), tr(e.what()) );
         return;
     }
 
-    this->playback_fps = 1;
+    if (this->container && this->container->is_neb_pathway()) {
+        this->set_axes_enabled(false);
+        this->set_pingpong_enabled(true);
+        this->set_rotation_enabled(false);
+        this->playback_fps = 60;
+    } else {
+        this->playback_fps = 1;
+    }
+
     if (this->fps_dropdown) {
         const int fps_index = this->fps_dropdown->findData(this->playback_fps);
         if (fps_index >= 0) {
             this->fps_dropdown->setCurrentIndex(fps_index);
         }
     }
 
     this->frame_direction = 1;
     emit new_container_loaded();
 }
 
 /**
  * @brief      Sets the camera align.
  *
  * @param      action  The action
  */
 void InterfaceWindow::set_camera_align(QAction* action) {
     this->anaglyph_widget->set_camera_alignment(action->data().toInt());
 }
 
 /**
  * @brief      Sets the camera mode (orthogonal or perspective).
  *
  * @param      action  The action
  */
